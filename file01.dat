package lister_intro


class Lister {

  def reverser (minListe: List[Any]) = minListe.reverse

  def fjernDuplikater (minListe: List[Any]) = minListe.distinct

  def finneForsteElement(minListe: List[Any]) = minListe.head

  def finneSisteElement(minListe: List[Any]) = minListe.last

  def finnToForsteElementer(minListe: List[Any]) = minListe.take(2)

  def finnBortsettFraForsteElement(minListe: List[Any]) = minListe.tail

  def finnBortsettFraToForsteElementer(minListe: List[Any]) = minListe.drop(2)

  def finnPartall(minListe: List[Int]) = minListe.filter(_ % 2 == 0)

  def kalkulerKubene(minListe: List[Int]) = minListe.map((n: Int) => n * n * n)

  def finnSublisteFraPredikat(minListe: List[Int], predikat: Int => Boolean) =  minListe.filter(predikat)

  def tvinneToLister(minListe1: List[Any], minListe2: List[Any]) = {
    //List((1,1)) //TODO
    val index: List[((Any, Any), Int)] = minListe1.zip(minListe2).zipWithIndex
    index.map (
      (element: ((Any, Any), Int)) =>
        if(element._2 % 2 == 0)
          element._1
        else
          element._1.swap
    )
  }

  def plukkeFraKanteneAvListen[A](minListe: List[A]): List[A] = {
    if (minListe.isEmpty)
      Nil
    else
      minListe.head :: plukkeFraKanteneAvListen(minListe.tail.reverse)
  }

  def summereAlleIntsIEnListe(minListe: List[Int]) =
    minListe.reduce((r,c) => r + c)

  def encodeSekvensLengdeIEnSortertListe(minListe: List[Any]) : List[(Int, Any)] =
    if (minListe.isEmpty)
      Nil
    else {
      val (packed, next) = minListe span {
        _ == minListe.head 
      }
      (packed.length, packed.head) :: encodeSekvensLengdeIEnSortertListe(next)
    }

}
